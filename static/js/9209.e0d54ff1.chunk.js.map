{"version":3,"file":"static/js/9209.e0d54ff1.chunk.js","mappings":"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","sources":["api/Association/info.js","pages/Common/AssociationLoginAfter.jsx","../node_modules/@tanstack/query-core/src/mutationObserver.ts","../node_modules/@tanstack/react-query/src/useMutation.ts"],"sourcesContent":["import authApi from \"../authApi\"\r\n\r\nexport const getAssociationLoginInfo = async () => {\r\n  const res = await authApi.get('associ/associloginread')\r\n  return res.data\r\n}","import { useMutation, useQuery } from '@tanstack/react-query'\r\nimport React, { useEffect } from 'react'\r\nimport { useNavigate } from 'react-router-dom'\r\nimport { useSetRecoilState } from 'recoil'\r\nimport { getAssociationLoginInfo } from '../../api/Association/info'\r\nimport LoadingModal from '../../components/UI/Atoms/Spinner/LoadingModal'\r\nimport assoInfoAtom from '../../recoil/atom/association/assoInfoAtom'\r\n\r\nconst AssociationLoginAfter = () => {\r\n  const navigate = useNavigate()\r\n\r\n  const setAssoInfo = useSetRecoilState(assoInfoAtom)\r\n\r\n  const { mutate } = useMutation(() => getAssociationLoginInfo(), {\r\n    onSuccess: (res) => {\r\n      setAssoInfo(res)\r\n\r\n      setTimeout(() => {\r\n        navigate('/association/home')\r\n        // window.location.reload()\r\n      }, 1000)\r\n    },\r\n\r\n    onError: (err) => {\r\n      alert('로그인에 실패하였습니다. \\n잠시후 다시 시도해 주세요.')\r\n      navigate('/logout')\r\n    }\r\n  })\r\n\r\n  useEffect(() => {\r\n    setTimeout(() => {\r\n      mutate()\r\n    }, 500)\r\n  },[])\r\n\r\n  return (\r\n    <>\r\n      <LoadingModal />\r\n    </>\r\n  )\r\n}\r\n\r\nexport default AssociationLoginAfter","import type { Action, Mutation } from './mutation'\nimport { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { shallowEqualObjects } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n"],"names":["getAssociationLoginInfo","authApi","res","data","navigate","useNavigate","setAssoInfo","useSetRecoilState","assoInfoAtom","mutate","useMutation","onSuccess","setTimeout","onError","err","alert","useEffect","MutationObserver","constructor","client","options","setOptions","bindMethods","updateResult","this","bind","reset","prevOptions","defaultMutationOptions","shallowEqualObjects","getMutationCache","notify","type","mutation","currentMutation","observer","onUnsubscribe","listeners","length","removeObserver","onMutationUpdate","action","notifyOptions","getCurrentResult","currentResult","undefined","variables","mutateOptions","build","addObserver","execute","state","getDefaultState","result","isLoading","status","isSuccess","isError","isIdle","notifyManager","context","onSettled","error","forEach","listener","Subscribable","arg1","arg2","arg3","parseMutationArgs","queryClient","useQueryClient","React","useSyncExternalStore","onStoreChange","subscribe","catch","noop","shouldThrowError","useErrorBoundary","mutateAsync"],"sourceRoot":""}